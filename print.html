<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Data Structures and Algorithm I</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction & Review</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="memory.html"><strong aria-hidden="true">1.1.</strong> Memory</a></li><li class="chapter-item expanded "><a href="abstraction.html"><strong aria-hidden="true">1.2.</strong> Data Abstraction and ADT</a></li></ol></li><li class="chapter-item expanded "><a href="bags.html"><strong aria-hidden="true">2.</strong> The Bag ADT</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bags-array.html"><strong aria-hidden="true">2.1.</strong> Array Implementation and Array Resizing</a></li><li class="chapter-item expanded "><a href="bags-ll.html"><strong aria-hidden="true">2.2.</strong> Linked List Implementation</a></li><li class="chapter-item expanded "><a href="bags-implementation.html"><strong aria-hidden="true">2.3.</strong> Comparing Implementations</a></li></ol></li><li class="chapter-item expanded "><a href="stack-queue-deque.html"><strong aria-hidden="true">3.</strong> Stacks, Queues, and Deques</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sqd-array.html"><strong aria-hidden="true">3.1.</strong> Array Implementation</a></li><li class="chapter-item expanded "><a href="sqd-ll.html"><strong aria-hidden="true">3.2.</strong> Linked List Implementation</a></li></ol></li><li class="chapter-item expanded "><a href="list.html"><strong aria-hidden="true">4.</strong> The List ADT</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="list-array.html"><strong aria-hidden="true">4.1.</strong> Array Implementation</a></li><li class="chapter-item expanded "><a href="list-ll.html"><strong aria-hidden="true">4.2.</strong> Linked List Implementation</a></li></ol></li><li class="chapter-item expanded "><a href="algorithms.html"><strong aria-hidden="true">5.</strong> Algorithm Analysis</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="algs-bag-list.html"><strong aria-hidden="true">5.1.</strong> Analysis of the Bag and List implementations</a></li></ol></li><li class="chapter-item expanded "><a href="recusrion.html"><strong aria-hidden="true">6.</strong> Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="divide-and-conquer.html"><strong aria-hidden="true">6.1.</strong> Divide and Conquer</a></li><li class="chapter-item expanded "><a href="backtracking.html"><strong aria-hidden="true">6.2.</strong> Backtracking Algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="sorting.html"><strong aria-hidden="true">7.</strong> Sorting</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="shellsort.html"><strong aria-hidden="true">7.1.</strong> ShellSort</a></li><li class="chapter-item expanded "><a href="merge-quick-sort.html"><strong aria-hidden="true">7.2.</strong> MergeSort and QuickSort</a></li><li class="chapter-item expanded "><a href="radixsort.html"><strong aria-hidden="true">7.3.</strong> Radix Sort</a></li></ol></li><li class="chapter-item expanded "><a href="iterators.html"><strong aria-hidden="true">8.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="dictionary.html"><strong aria-hidden="true">9.</strong> The Dictionary ADT</a></li><li class="chapter-item expanded "><a href="hashing.html"><strong aria-hidden="true">10.</strong> Hashing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hash-functions.html"><strong aria-hidden="true">10.1.</strong> Hash Functions and Collisions</a></li><li class="chapter-item expanded "><a href="open-addressing.html"><strong aria-hidden="true">10.2.</strong> Open Addressing</a></li><li class="chapter-item expanded "><a href="separate-chaining.html"><strong aria-hidden="true">10.3.</strong> Separate Chaining</a></li><li class="chapter-item expanded "><a href="hashing-analysis.html"><strong aria-hidden="true">10.4.</strong> Comparison and Analysis of Hashing</a></li><li class="chapter-item expanded "><a href="hash-table.html"><strong aria-hidden="true">10.5.</strong> Hash Table</a></li></ol></li><li class="chapter-item expanded "><a href="string-matching.html"><strong aria-hidden="true">11.</strong> String Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rabin-karp.html"><strong aria-hidden="true">11.1.</strong> Rabin Karp Approach</a></li><li class="chapter-item expanded "><a href="boyer-moore.html"><strong aria-hidden="true">11.2.</strong> Boyer Moore Approach</a></li><li class="chapter-item expanded "><a href="string-matching-analysis.html"><strong aria-hidden="true">11.3.</strong> Comparison and Analysis</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Data Structures and Algorithm I</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction--review"><a class="header" href="#introduction--review">Introduction &amp; Review</a></h1>
<p>The goal of this course is to study the basic data structures and algorithms of computer science (such as lists, stacks, queues, and hash tables), as well as their implementations. We will begin by examining each data structure from the <em>users</em> point of view and answering questions like &quot;<em>What are these data structures and how do I use them in my programs?</em>&quot; Then, we will shift our focus to the <em>implementers</em> point of view, studying the various ways in which each data structure can be implemented, and what each implementation entails (such as run-time differences, code complexity, and modifiability). Lastly, we will use these data structures as the underlying foundation to build and examine algorithms which can solve many classical computer science problems.</p>
<p>To aid in our studies, we will use the <a href="https://en.wikipedia.org/wiki/Java_(programming_language)">Java Programming Language</a> to examine the specific implementations of each data structure and algorithm. In this process, we will attain a better understanding of programming ideas and techniques including <a href="oop.html">object-oriented programming</a>, dynamic memory utilization, recursion (with backtracking) and other principles. Furthermore, as our programming skills improve, we will learn to utilize the vast capabilities of the Java programming language more effectively.</p>
<h2 id="java-review"><a class="header" href="#java-review">Java Review</a></h2>
<p>Since we will be heavily relying on Java to examine our data structures and algorithms, it is expected that you have some previous experience with it. That means, you should be familiar with:</p>
<ul>
<li>Basic Java program structure and syntax</li>
<li>Control structures such as loops and conditionals</li>
<li>Methods and method calls
<ul>
<li>Difference between static and instance methods</li>
<li>Concept of method overloading (AKA <em>ad hoc polymorphism</em>)</li>
<li>Recursive methods</li>
</ul>
</li>
<li>Variables and objects
<ul>
<li>Difference between Instance and method variables</li>
<li>Difference between objects and references</li>
<li>Dynamic nature of Java objects</li>
</ul>
</li>
<li>Classes
<ul>
<li>How to declare new classes</li>
<li>Difference between <code>private</code>, <code>public</code> and <code>protected</code> classes</li>
<li>Building new classes via <strong>composition</strong> and <strong>inheritance</strong></li>
<li><strong>Polymorphism</strong> via method overriding and dynamic binding</li>
</ul>
</li>
<li>Interfaces</li>
<li>Arrays and array lists (contiguous memory)</li>
<li>Nodes and linked lists (non-contiguous memory)</li>
<li>Simple Java files and graphics</li>
<li>Exception handling</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory"><a class="header" href="#memory">Memory</a></h1>
<p>Let us first talk about some consequences with using the Java programming language, mainly how Java treats <em>References, Pointers, and Memory</em>. Recall that Java has two kinds of variables: <strong>primitive</strong> and <strong>reference</strong>. Primitive types are the basic building block data of the language and include the <code>int</code>, <code>double</code>, <code>boolean</code>, and <code>char</code> (among others) where as Reference types are variable that <em>refer</em> to objects. As we will be programming primarily in Java, it is important know how Java treats each type of variable.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Variable Type</th><th><strong>Primitive Type</strong></th><th><strong>Reference Type</strong></th></tr></thead><tbody>
<tr><td style="text-align: right">How do we define it?</td><td><code>int i;</code></td><td><code>String s;</code></td></tr>
<tr><td style="text-align: right">How do we initialize it?</td><td><code>i = 445;</code></td><td><code>s = new String(&quot;Hello!&quot;);</code></td></tr>
<tr><td style="text-align: right">What does it store?</td><td>The actual underlying type is stored at a location in memory</td><td>The address of an object is stored at a location in memory</td></tr>
<tr><td style="text-align: right">How do we copy it?</td><td><code>int j = i;</code> copies the value at <code>i</code> to <code>j</code>.</td><td><code>String t = s;</code> copies the reference of <code>s</code> to <code>t</code> and does not directly affect the object. <br> <code>String u = new String(s)</code> creates a new object whose contents are identical to <code>s</code></td></tr>
<tr><td style="text-align: right">How do we compare it?</td><td><code>if (i == j)</code> compares the two values</td><td><code>if (s == t)</code> returns true because they both have same references. However, <code>if (s == u)</code> returns false since <code>s</code> and <code>u</code> have different references (even though their value is the same).</td></tr>
</tbody></table>
</div>
<p>One important consequence of having two types is that operators can only operate properly on primitive types. If we were to use an operator (such as <code>==</code>) on a reference type, it will not work as expected. This is because the operators operate directly on the references (comparing the memory address held by the reference variables) and not the objects the variables are referring to.</p>
<p>Instead, to compare the actual objects at the reference, we need to use named methods that compares the content (since Java, unlike C++ or Python, does not support operator overloading). Typically, these methods are called <code>.equals()</code> or <code>.comparesTo()</code> and are predefined in most library classes, but can also be redefined in our own classes as needed.</p>
<h2 id="references-vs-pointers"><a class="header" href="#references-vs-pointers">References vs Pointers</a></h2>
<p>Many lower level programming languages, such as C, support <strong>pointer variables</strong> which stores memory addresses and allow us to directly access data in the RAM. </p>
<p><img src="assets/Pointers.png" alt="Pointers" /></p>
<p>Here, variables <code>x</code> and <code>y</code> are pointers which store memory locations. The objects themselves live at the memory locations the pointer points to. Note, since these variables holds an address, operations on the variables means operations on the addresses (and not the data at the address). For instance, if we run <code>x = y;</code>, we would have both <code>x</code> and <code>y</code> pointing to the same memory location (and hence the same object). </p>
<p><img src="assets/aliasing.png" alt="aliasing.png" /></p>
<p>Now, <code>x</code> is no longer pointing to the original memory address, but at the same address <code>y</code> is pointing to. When, two (or more) pointers point to the same object, this is called <strong>aliasing</strong>.</p>
<p>To gain access to the object that <code>x</code> points to, we can <strong>dereference a pointer</strong> (explicitly tell the computer to go to that address). In C, this is done with the <code>*</code> operator. Hence, if we really wanted to have two separate objects, but want one of them to be a copy of the other, we could do the following (assuming the data is set up properly):</p>
<pre><code class="language-C">*x = *y;
</code></pre>
<p>Now, <code>x</code> is points to its original location (as does <code>y</code>), but the values at the position <code>x</code> is pointing to is changing:</p>
<p><img src="assets/dereferencing%20a%20pointer.png" alt="dereferencing a pointer" /></p>
<p>Java, by contrast, does not have any pointers. Instead, it only has <strong>references</strong> which behave similarly to pointers but with more restrictions. For instance, we cannot explicitly dereference variables (thus there is no dereference operator). Instead, dereferencing is handled implicitly and we can access data and methods using the &quot;dot&quot; operator. For example, to copy an an entire object we would use a method such as a <code>clone()</code> method (also called a <strong>copy constructor</strong>). </p>
<p>Yet, even without pointers, <strong>aliasing</strong> can still occur in Java.</p>
<pre><code class="language-Java">StringBuilder S1 = new StringBuilder(&quot;Hello&quot;);
StringBuilder S2 = S1;
S1.append(&quot; There&quot;);
S2.append(&quot; CS 0445 Students&quot;);
System.out.println(S1.toString());
// Output: Hello There CS 0445 Students
</code></pre>
<p>Here, we mutated using two different variables but both mutated the same object. Hence, you must be aware of when you want a new object or a reference to an old one.</p>
<h2 id="java-memory-use"><a class="header" href="#java-memory-use">Java Memory Use</a></h2>
<p>Java is a high-level language in that memory allocation is handled dynamically and implicitly. Specifically, memory is allocated using the <code>new</code> operator and once allocated, objects exist for an indefinite period of time, as long as there is an active reference to the object. When there are no references to objects, they are no longer accessible in the program, and marked for <strong>Garbage Collection</strong>.</p>
<p>The Java <strong>garbage collector</strong> is a process that runs in the background during program execution. When the amount of available memory runs low, the garbage collector reclaims objects that have been marked for collection. A fairly sophisticated algorithm is used to determine which objects can be garbage collected but due to its long run-time, if we have plenty of memory is available, the garbage collector will not run.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-abstraction-and-adt"><a class="header" href="#data-abstraction-and-adt">Data Abstraction and ADT</a></h1>
<h2 id="objected-oriented-programming"><a class="header" href="#objected-oriented-programming">Objected Oriented Programming</a></h2>
<p>In Java, most data structures are organized into <strong>classes</strong> which are basically <em>blueprints</em> for data. The code below defines a Person class, but there are no instances of that class yet; there are no people because we haven't created them.</p>
<pre><code class="language-Java">class Person {
	private String name;
	private int age;
	private String address;
	//...
}
</code></pre>
<p>Classes are useful because they allow us to <strong>encapsulate</strong> the <em>data and operations</em> together (typically through <em>instance data</em> and <em>instance methods</em>). This is particularly useful for restricting access to specific data or implementation details (i.e, <strong>data hiding</strong> through non-public declarations). The author of the class can hide the details of the data type from the user and vary the levels of accessibility by using the <code>public</code>, <code>protected</code>, and <code>private</code> modifiers.</p>
<table>
  <tbody>
    <tr>
      <th></th>
      <th>Class</th>
      <th>Package</th>
      <th>Subclass</th>
      <th>World</th>
    </tr>
    <tr>
      <th><code>public</code></th>
      <td style="text-align:center;background-color:#b0f4b0;">y</td>
      <td style="text-align:center;background-color:#b0f4b0;">y</td>
      <td style="text-align:center;background-color:#b0f4b0;">y</td>
      <td style="text-align:center;background-color:#b0f4b0;">y</td>
    </tr>
    <tr>
      <th><code>protected</code></th>
      <td style="text-align:center;background-color:#b0f4b0;">y</td>
      <td style="text-align:center;background-color:#b0f4b0;">y</td>
      <td style="text-align:center;background-color:#b0f4b0;">y</td>
      <td style="text-align:center;background-color:pink;">n</td>
    </tr>
    <tr>
      <th>No Modifier</th>
      <td style="text-align:center;background-color:#b0f4b0;">y</td>
      <td style="text-align:center;background-color:#b0f4b0;">y</td>
      <td style="text-align:center;background-color:pink;">n</td>
      <td style="text-align:center;background-color:pink;">n</td>
    </tr>
    <tr>
      <th><code>private</code></th>
      <td style="text-align:center;background-color:#b0f4b0;">y</td>
      <td style="text-align:center;background-color:pink;">n</td>
      <td style="text-align:center;background-color:pink;">n</td>
      <td style="text-align:center;background-color:pink;">n</td>
      </tr>
  </tbody>
</table>
<p>However, data hiding also provides certain benefits to the user. Thanks to it, the user does not need to know (or know) the implementation details but can still access the class functionalities and data (provided they know the <em>nature of the data</em> and the public method specifications). For instance, a programmer can use the <code>BigInteger</code> or <code>ArrayList</code> classes without knowing how exactly they work (just that they do work).</p>
<p>This idea of data hiding is called <strong>data abstraction</strong> and is closely related to <em>abstract data types (ADTs)</em>. Through <strong>encapsulation</strong>, access to the implementation details of a class can be restricted and through <em>data abstraction</em>, a user can use the class effectively without having to know these implementation details. From an implementer's perspective, public members (often public methods) give the interface and functionality of the objects, whereas the private members (often private data) hide the implementation details.</p>
<p>We can use a few keywords to modify the data in the objects. With the <code>static</code> keyword, we can define a data that belongs to the class rather than the objects. Data that is defined using this keyword will be shared by all instances (objects) of the class. The <code>final</code> keyword provides various functionalities depending on the context. For variables, the <code>final</code> keyword means the value cannot change after being initially assigned; for methods, it means they cannot be overridden in a child classes; and for classes, it means they cannot be the parent in an inheritance relationship (no subclasses or child classes can be made from it).</p>
<h3 id="instantiating-classes"><a class="header" href="#instantiating-classes">Instantiating Classes</a></h3>
<p>Once we've defined a class, we can create a new instance of the class by using the <code>new</code> keyword and calling the constructor method (defined within the class). These instances are called <strong>objects</strong> and each object has the functionality and data as defined in the class.</p>
<h3 id="building-new-classes-composition"><a class="header" href="#building-new-classes-composition">Building New Classes: Composition</a></h3>
<p>Java has many predefined classes in its <a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/module-summary.html"><strong>class library</strong></a>, which contains hundreds of classes where each class is designed for a specific purpose. However, there are many situations where we may need a class that is not already defined. In this case, we must define it ourselves. One technique for doing this is called <strong>Composition (Aggregation)</strong>.</p>
<p>With composition, we can build new classes using components (instance variables) that are from previously-defined classes. We <em>compose</em> the class from existent &quot;pieces&quot; and define a &quot;<strong>has-a</strong>&quot; relationship between the new class and the old classes. Consider the following code as an example:</p>
<pre><code class="language-Java">public class CompoClass {
  private String name;
	private Integer size;
	public CompoClass(String n, int i) {
		name = new String(n);
		size = new Integer(i);
	}
	public void setCharAt(int i, char c) {
		StringBuilder b = new StringBuilder(name);
		b.setCharAt(i, c);
		name = b.toString();
	}
}
</code></pre>
<h2 id="mutable-and-immutable-objects"><a class="header" href="#mutable-and-immutable-objects">Mutable and Immutable Objects</a></h2>
<p>Notice that we are changing the string in a rather convoluted way. This is because we cannot access the inner representation of the String. However, even if we were able to access the string <code>name</code> it would prove difficult to change the content of the String. This is because String objects in Java are <strong>immutable</strong>. Immutable objects are instantiated from classes that do not contain mutator methods. The <code>String</code> class is a primary example as it cannot be altered after being created. However, other immutable objects exists such as the <code>Integer</code> or <code>Float</code> classes which have accessor methods but no mutators.</p>
<p>Conversely, objects that have mutator methods (and allow us to change the content of the object) are called <strong>mutable</strong>. For instance, the <code>StringBuilder</code> class contains the <code>append()</code> method that allows the user to add characters to the current Stringbuilder. Similarly, the <code>ArrayList</code> class has an <code>add()</code> and <code>remove()</code> methods that allow us to manipulate the data that it stores.</p>
<p>As a consequence of being immutable, objects such as strings require much more work for an action that could be done simply with mutation. For immutable objects, modifying them often means creating a new object and reassigning them. For example, consider concatenating <code>String</code>s.</p>
<pre><code class="language-Java">String S1 = &quot;Hello &quot;;
S1 = S1 + &quot;there&quot;;
</code></pre>
<p>Although Java is smart enough to know that we are appending Strings, under the hood, it creates a new String object with &quot;Hello there&quot; as the constructor argument and reassigns it to <code>S1</code>. Hence, if this operation is done repeatedly it will cause a lot of overhead, and run-time will be very poor.</p>
<p>Yet, there are issues with being mutable as well. If we add an object to a collection (such as a list), and outside objects/methods that still maintain a reference to the object will still be able to modify the object and possibly destroy the property of the collection. For example, assume we make a subclass of <code>ArrayList</code>, called <code>SortedArrayList</code>. Now the data must be maintained in order based on the <code>compareTo()</code> method. Yet, if we have a <code>SortedArrayList</code> of <code>StringBuilder</code>s, we can still change one of the <code>StringBuilder</code>s (as long we have a reference), and modify it to break the ordering property.</p>
<p>As a potential solution, we can put <strong>copies</strong> of the original objects into the collection (hence any outside references won't be able to change the new copied object). However, we still need to be careful not to mutate the objects within our collection. For example, an some access methods return references to the objects within the collection (which means that the objects within the collections can be mutated again). Hence, to be very safe, we should ensure that our accessor methods only return copies of the objects rather than references to the original.</p>
<h2 id="making-copies"><a class="header" href="#making-copies">Making Copies</a></h2>
<p>But how do we make copies? A typical Java object can be copied using a <strong>copy constructor</strong> or a <strong><code>clone()</code></strong> method. The <code>clone()</code> method is defined in class <code>Object</code> meaning it will work for all Java classes. For example, Java arrays and some other classes already implement a <code>clone()</code> method for us to use. However, for classes we defined, we need to ensure that they work properly. Hence we need to <strong>override</strong> <code>.clone()</code> in our own classes.</p>
<h3 id="levels-of-copying"><a class="header" href="#levels-of-copying">Levels of Copying</a></h3>
<p>If we copy an object, what do we do about any references within that object? </p>
<p>In a <strong>shallow copy</strong>, we simply assign those references to the new object. Thus, both copies of the object have references to the same &quot;nested&quot; objects.</p>
<p>In a <strong>deep copy</strong>, however, all nested objects must also be copied meaning that each copies of the object have references to different nested objects.</p>
<pre><code class="language-Java">public class SBArray
{
	private StringBuilder [] A;
	private int size;
	// shallow copy
	public SBArray(SBArray old)
	{
		A = old.A;
		size = old.size;
	}
	// deeper copy
	public SBArray(SBArray old)
	{
		A = new StringBuilder[
				old.A.length];
		size = old.size
		for (int i=0; i&lt;size; i++)
			A[i] = old.A[i];
	}
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Shallow Copy</th><th>Deeper Copy</th><th>Deep Copy</th></tr></thead><tbody>
<tr><td>Copy references from old object to new object.</td><td>We make a copy of the array for the new object</td><td>We make a copy of the array for the new object</td></tr>
<tr><td>Objects within the copied object are shared by original and copy</td><td>But we do not copy the StringBuilders stored within it</td><td>We also copy all of the StringBuilders stored in the array</td></tr>
<tr><td></td><td>Original and copy are still &quot;connected&quot; at some point</td><td>Original and copy are completely separated from each other</td></tr>
</tbody></table>
</div>
<p>Generally speaking, (true) deep copying is more difficult than shallow copying. This is because for a deep copy, we need to follow all references in the original and make copies for the copy which could be several levels deep.</p>
<p>For example, a object has a reference to front node. A shallow copy would only copy this single reference, but, a deep copy would have to traverse the entire list, copying each node, and copying the data in each node, and so on.... In fact, it's impossible to say that a copy is truly deep unless all copies made are deep.</p>
<h3 id="building-new-classes-inheritance"><a class="header" href="#building-new-classes-inheritance">Building New Classes: Inheritance</a></h3>
<p>Besides, composition, another technique to building classes is called <strong>inheritance</strong>. With inheritance, we build a new class (subclass) by extending a previously-defined class (superclass).</p>
<p>Note that the subclass has all of the properties(data and methods) defined in the superclass. Inheritance defines an <strong>is-a</strong> relationship between subclass and superclass. That is, a subclass <strong>is a</strong> superclass, and subclass objects can be assigned to superclass variables. However, the opposite is not true. That is, as superclass <strong>IS NOT</strong> a subclass and superclass objects cannot be assigned to subclass variables.</p>
<pre><code class="language-Java">// Assume SubFoo is a subclass of Foo – consider the
// statements below
Foo f1;
SubFoo s1;
f1 = new Foo();  // obviously fine
f1 = new SubFoo();  // fine, but now we
        // only have access to the public methods and
        // variables initially defined in class Foo()
f1.foomethod();  // fine
f1.subfoomethod();  // illegal – method does not exist
((SubFoo)f1).subfoomethod(); // fine, since now ref.
		    // has been cast to the actual class
s1 = new SubFoo();
s1.subfoomethod();
s1.foomethod();
s1 = new Foo();  // illegal – isA is one way
</code></pre>
<h4 id="polymorphism"><a class="header" href="#polymorphism">Polymorphism</a></h4>
<p><strong>Polymorphism</strong> allows superclass and subclass objects to be accessed in a regular, consistent way. For example, an array or collection of <strong>superclass references</strong> can be used to access a <strong>mixture of superclass and subclass objects</strong>. So, if a method is defined in both the superclass and subclass (with identical signatures), the <strong>version corresponding to each class will be used</strong> in a call from the array. The idea is that the methods are similar in nature but the redefinition in the subclass gears the method more specifically to the data / properties of the subclass.</p>
<p>For example, consider the class <code>Animal</code> which describes a large number of objects. Let's say each Animal can <code>move()</code>. Without more knowledge of the specific animal, we don't really know how the animal would move. But now, consider a subclass of <code>Animal</code>, say <code>Bird</code>. We can redefine (override) the <code>move()</code> method to reflect the specific details of a Bird such as, <em>it will fly.</em></p>
<pre><code class="language-Java">public class Animal
{
	// omitted decls
	public void move()
	{
		System.out.println(&quot;I move&quot;);
	}
}

public class Bird extends Animal
{
	// omitted decls
	public void move()
	{
		System.out.println(&quot;I fly&quot;);
	}
}
</code></pre>
<p>Generally, each subclass would override the <code>move()</code> method in its own way.</p>
<pre><code class="language-Java">Animal [] A = new Animal[3];
A[0] = new Bird();
A[1] = new Person();
A[2] = new Fish();
for (int i = 0; i &lt; A.length; i++)
		A[i].move();
</code></pre>
<p>Notice that each call is <strong>syntactically identical</strong>. Their reference and method spec(s) are the same; but the code is executed is based on type of object being stored Polymorphism is implemented utilizing two important ideas: <strong>(1) Method Overriding</strong> and <strong>(2) Dynamic (or late) Binding</strong></p>
<hr />
<hr />
<p>When a superclass's method is redefined in the subclass with an <strong>identical method signature</strong>, this is called <strong>method overriding</strong>. Since the signatures are identical, rather than overloading the method (ad hoc polymorphism), it is instead <strong>overriding the method</strong>.</p>
<ul>
<li>For a subclass object, the definition in the subclass <em>replaces</em> the version in the superclass, even if a superclass reference is used to access the object</li>
<li>Superclass version can still be accessed via the <code>super</code> reference</li>
</ul>
<h4 id="dynamic-or-late-binding"><a class="header" href="#dynamic-or-late-binding">Dynamic (or late) Binding</a></h4>
<p>Dynamic binding means that the code executed for a method call is associated with the call during <strong>run-time</strong>. The actual method executed is determined by the <strong>type of the object</strong>, not the type of the reference.</p>
<p>Polymorphism is very useful if we want to access collections of mixed data types consistently. For example, a collection of different graphical figures could call each <code>draw()</code> method consistently, but which would be drawn differently.</p>
<h3 id="abstract-classes"><a class="header" href="#abstract-classes">Abstract Classes</a></h3>
<p>Sometimes in a class hierarchy, a class may be defined simply to give cohesion to its subclasses. <em>I.e.,</em> No objects of that class will ever be defined, but instance data and methods will still be inherited by all subclasses This is an <strong>abstract class</strong>.</p>
<ul>
<li>Keyword <code>abstract</code> used in declaration</li>
<li>One or more methods may be declared to be abstract and are thus not implemented</li>
<li>No objects may be instantiated</li>
</ul>
<p>Subclasses of an abstract class must implement all abstract methods, or they too must be declared to be abstract.</p>
<h4 id="advantages-of-an-abstract-class"><a class="header" href="#advantages-of-an-abstract-class">Advantages of an Abstract Class</a></h4>
<ul>
<li>We can still use superclass reference to access all subclass objects in polymorphic way.
<ul>
<li>If a method does not make sense or is not fully realizable in the superclass, we declare it as abstract.
For example, the <code>move()</code> method in <code>Animal</code> may be better as an abstract method. In this case <code>Animal</code> would need to be an abstract class.</li>
</ul>
</li>
<li>We can still define any common data and operations in the superclass, which would be inherited by the subclasses.</li>
<li>Helps to organize class hierarchy</li>
</ul>
<h3 id="interfaces"><a class="header" href="#interfaces">Interfaces</a></h3>
<p>Unlike some programming langauges, Java allows <em>only</em> <strong>single inheritance</strong>. That is, one class cannot have more than one parent. Java language developers chose to offer only single inheritance for two basic reasons:
1. simplifying the implementation of the compiler/interpreter
2. it's easier for programmers to understand what is happening when there is only single inheritance</p>
<p>However, it is sometimes useful to access an object through more than one type of superclass references. Often, when a programmer wants multiple inheritance, they want it for polymorphism (i.e. they want a class to be able to look like two different other things). Java offers a way to do this with <strong>interfaces</strong>.</p>
<p>An <strong>interface</strong> is a named set of methods (i.e. method headers, but no bodies). Basically, an interface is an abstract class without any instance data (although there are differences between abstract classes and interfaces).</p>
<p>In interfaces:</p>
<ol>
<li>Static <em>constants</em> are allowed</li>
<li>Default methods are allowed</li>
<li>Static methods are allowed</li>
<li><strong>No instance data</strong> is allowed</li>
<li>Regular instance methods have <strong>no bodies</strong></li>
<li>Interface itself <strong>cannot be instantiated</strong></li>
</ol>
<p>Any Java class can implement an interface (no matter what its inheritance). In fact, any Java class <strong>can implement multiple interfaces</strong>. To implement an interface, a class must declare so in the class header and implement all methods in the interface.</p>
<p>For example, consider the following interfaces:</p>
<pre><code class="language-Java">public interface Laughable
{
	public void laugh();
}
public interface Booable
{
	public void boo();
}
</code></pre>
<p>Note that any Java class can implement <code>Laughable</code> by implementing the method <code>laugh()</code>, implement <code>Booable</code> by implementing the method <code>boo()</code>.</p>
<pre><code class="language-Java">public class Comedian implements Laughable, Booable
{
	// various methods here (constructor, etc.)
	public void laugh()
	{
		System.out.println(“Ha ha ha”);
	}
	public void boo()
	{
		System.out.println(“You stink!”);
	}
}
</code></pre>
<p>All of the polymorphism behavior also applies to interfaces. The interface acts as a superclass and the implementing classes are like subclasses to it. An interface reference variable <strong>can be used to reference any object that implements that interface</strong> and <strong>only interface methods are accessible through that interface reference.</strong></p>
<pre><code class="language-Java">Laughable [] funny = new Laughable[3];
funny[0] = new Comedian();
funny[1] = new SitCom(); // implements Laughable
funny[2] = new Clown();  // implements Laughable
for (int i = 0; i &lt; funny.length; i++)
	funny[i].laugh();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-bag-adt"><a class="header" href="#the-bag-adt">The Bag ADT</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array-implementation-and-array-resizing"><a class="header" href="#array-implementation-and-array-resizing">Array Implementation and Array Resizing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linked-list-implementation"><a class="header" href="#linked-list-implementation">Linked List Implementation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparing-implementations"><a class="header" href="#comparing-implementations">Comparing Implementations</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stacks-queues-and-deques"><a class="header" href="#stacks-queues-and-deques">Stacks, Queues, and Deques</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array-implementation"><a class="header" href="#array-implementation">Array Implementation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linked-list-implementation-1"><a class="header" href="#linked-list-implementation-1">Linked List Implementation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-list-adt"><a class="header" href="#the-list-adt">The List ADT</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array-implementation-1"><a class="header" href="#array-implementation-1">Array Implementation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linked-list-implementation-2"><a class="header" href="#linked-list-implementation-2">Linked List Implementation</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorithm-analysis"><a class="header" href="#algorithm-analysis">Algorithm Analysis</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="analysis-of-the-bag-and-list-implementations"><a class="header" href="#analysis-of-the-bag-and-list-implementations">Analysis of the Bag and List implementations</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recursion"><a class="header" href="#recursion">Recursion</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="divide-and-conquer"><a class="header" href="#divide-and-conquer">Divide and Conquer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="backtracking-algorithms"><a class="header" href="#backtracking-algorithms">Backtracking Algorithms</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sorting"><a class="header" href="#sorting">Sorting</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shellsort"><a class="header" href="#shellsort">ShellSort</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mergesort-and-quicksort"><a class="header" href="#mergesort-and-quicksort">MergeSort and QuickSort</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="radix-sort"><a class="header" href="#radix-sort">Radix Sort</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-dictionary-adt"><a class="header" href="#the-dictionary-adt">The Dictionary ADT</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashing"><a class="header" href="#hashing">Hashing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash-functions-and-collisions"><a class="header" href="#hash-functions-and-collisions">Hash Functions and Collisions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-addressing"><a class="header" href="#open-addressing">Open Addressing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="separate-chaining"><a class="header" href="#separate-chaining">Separate Chaining</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparison-and-analysis-of-hashing"><a class="header" href="#comparison-and-analysis-of-hashing">Comparison and Analysis of Hashing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hash-table"><a class="header" href="#hash-table">Hash Table</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-matching"><a class="header" href="#string-matching">String Matching</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rabin-karp-approach"><a class="header" href="#rabin-karp-approach">Rabin Karp Approach</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boyer-moore-approach"><a class="header" href="#boyer-moore-approach">Boyer Moore Approach</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comparison-and-analysis"><a class="header" href="#comparison-and-analysis">Comparison and Analysis</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
